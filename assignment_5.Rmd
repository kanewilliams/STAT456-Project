---
title: "Assignment 5 - Decomposing New Zealand Electrical Demand using stl() and str()"
author:
- name: Kane Williams (pkw21@uclive.ac.nz)
output:
  pdf_document:
    toc: true
  html_document:
    toc: true
    toc_float: true
    highlight: tango
    theme: flatly
header-includes: \usepackage{amsmath}
subtitle: "STAT456-24S2 - Time Series and Stochastic Processes"
editor_options:
  markdown:
    wrap: 72
---

<!-- <style> -->

<!-- .boxTask { -->
<!-- background-color: lightblue; -->
<!-- color: black; -->
<!-- border: 2px solid black; -->
<!-- margin: 5px; -->
<!-- padding: 5px; -->
<!-- font-style: italic; -->
<!-- } -->

<!-- /* Centered headings */ -->
<!-- h1, h2, h3, h4, h5, h6 { -->
<!--   text-align: center; -->
<!-- } -->

<!-- </style> -->



<!-- <style> -->

<!-- .boxTask { -->
<!-- background-color: lightblue; -->
<!-- color: black; -->
<!-- border: 2px solid black; -->
<!-- margin: 5px; -->
<!-- padding: 5px; -->
<!-- font-style: italic; -->
<!-- } -->

<!-- /* Centered headings */ -->
<!-- h1, h2, h3, h4, h5, h6 { -->
<!--   text-align: center; -->
<!-- } -->

<!-- </style> -->

# Introduction

In this assignment/project, an 8-week period of New Zealand's historical electricity demand will be
decomposed using two different methods, `stl()` and the newer `str()`.

The resulting decompositions will be compared (i) visually, (ii) through an analysis of the residuals, and (iii) through their ability to forecast.
  
It will be discovered that *bla bla bla TODO*.

## Electricity Demand in New Zealand

New Zealand's electrical demand (two thirds of which are from households and industry (MBIE, 2024)) is influenced by factors such as temperature, where colder days may drive up energy demand for heating, and weekends, whereupon employees stay at home and industry ceases or slows down electrical demand. This means that there will be at least daily, weekly, and yearly seasonal components in New Zealand's electrical demand. Further understanding the exact effects of each of these seasonal components requires decomposing a time series into them.

## Decomposition Techniques

### `stl()`

`stl()` is an R function that decomposes time series into three components: trend, seasonal, and remainder. It is based on the work of Cleveland (1990) and works by using LOESS (Locally Estimated Scatterplot Smoothing) to iteratively refine estimates of each component. The method was designed to be (i) simple to use, (ii) fast to compute, and (iii) allow for specifying seasonal/trend smoothing in a continuous way. It was designed for only a single seasonal component, although it can be adapted for multiple seasonalities through nested applications.


### `str()`

`str()` is an R function developed by Dokumentov and Hyndman (2021) that decomposes time series into multiple seasonal components. It is based on a regularized optimization, and is related to ridge regression. It attempts to address limitations in other methods by allowing for not only multiple seasonal patterns, but also (i) non-integer periods, (ii) interactions between the components, (iii) complex topologies such as modelling working days and holidays, and even (iv) covariates such as temperature. Furthermore, as it is based on a statistical model, confidence intervals can be computed.

# Data

## Data Description

The dataset chosen was: **Demand trends**.

-   It was pulled from the [Electricity
    Authority](https://www.emi.ea.govt.nz/Wholesale/Reports/W_GD_C?DateFrom=20190901&DateTo=20240831&RegionType=NZ&_rsdr=L60M&_si=_dr_DateFrom%7C20140101,_dr_DateTo%7C20231231,_dr_RegionType%7CNZ,_dr__rsdr%7CL10Y,v%7C4)
    with the following parameters:
    -   **Date Range**: 01 Jan 2014 - 31 Dec 2023 ('Latest 10 Calender
        Years')
    -   **Region Type**: New Zealand
    -   **Time Scale** Trading Period (i.e. half-hourly data)

Note that the unit of measurement is GWh (Gigawatt hours).

This data will then be reduced to the 6 weeks beginning from `February 13 2023`. This date and length was chosen because it (i) avoids New Zealand's public holidays, leading to a simpler time series to model and (ii) conveniently begins on a Monday which will make the plots easier to interpret. 

6 weeks was chosen because it is small enough that it is easy to distinguish each week and day in a single plot, and it is large enough to exhibit multiple-seasonality: in particular hourly and weekly seasonality.

## Data Import

```{r echo=FALSE}
source("./src/packages.R")
knitr::opts_chunk$set(tidy.opts = list(width.cutoff = 80), tidy = TRUE)
```

First the data will be read in. Afterwards, it will be filtered for relevant dates/columns. 

```{r}
# READ DATA
file_path <- "./data/NZ_Electricity_Demand_2014-2023.csv"
header <- c("Period_Start", "Period_End", "Region_ID", "Region", "Price")

raw_data <- read_csv(file_path, 
                     skip = 12, 
                     col_names = header,
                     show_col_types = FALSE) %>%
  mutate(
    Price = as.numeric(Price),
    Period_Start = dmy_hms(Period_Start),
    Period_End = dmy_hms(Period_End)
  )
```


```{r}
# FILTER DATA (for ease of use)
filtered_data <- raw_data %>%
  # Select relevant columns
  dplyr::select(Period_Start, Price) %>%
  # Filter for 4 weeks starting from Monday, Feb 13, 2023
  dplyr::filter(Period_Start >= as.Date("2023-02-13") & 
                Period_Start < as.Date("2023-02-13") + weeks(4))

head(filtered_data, 3)
```

The data will now be converted to a `ts` (time series) object for `stl()`, and an `msts` (multi-seasonal time series) object for `str()`. Note that these objects have difficulty with setting 'start' dates if it is half-hourly data. So they will 'start' at 2023-01-01. This will not impact any analyses.

```{r}
# CREATE ts OBJECT (for stl)
season1 <- 48 # day
season2 <- 48 * 7 # week
season3 <- 48 * 7 * 52.25 # year

# Only one seasonality allowed for `ts`, so will use weekly.
elec_ts <- ts(filtered_data$Price, 
                     start = c(2023), 
                     frequency = season2)

head(elec_ts)
```

```{r}
# CREATE msts ("multi-seasonal time series") OBJECT

elec_msts <- forecast::msts(as.vector(filtered_data$Price), 
                     start = c(2023),
                     seasonal.periods = c(season1, season2, season3)
                  )

plot(elec_msts, ylab="Electricity demand", main="New Zealand electrical demand - 4 weeks from February 13 2023")
```

# Decomposition using stl()

```{r}
elec_stl <- stl(elec_ts, s.window="periodic")

elec_stl %>% autoplot
```

For this time period, there was not much of any increasing/decreasing trend. `stl` picked up a "trend"
**TODO** Do I need to change any settings? e.g. t.window, s.window

# Decomposition using str()

```{r}
elec_str <- AutoSTR(elec_msts, gapCV = 48, confidence = 0.95)
```

```{r}
plot(elec_str)
```

The str() decomposition shows, from the top down:

-   An "observed trend" component.
-   A daily seasonal component.
-   A weekly seasonal component.
-   A random (i.e. residual) component.
-   A fit/forecast using the above seasonal and trend components.

It can be noticed that:

-   TODO, bla bla

# Comparison of stl and str

This will be done three ways:

1)  A visual inspection,
2)  By analysing the residuals and performing a ACF/PACF/e.t.c., and
    lastly
3)  YOUR CHOICE CLAUDE

### Visual Inspection

Bla bla

### Analysis of Residuals

First the PACF/ACF of the `stl` output will be plotted, followed by the PACF/ACF of `str`.

```{r}
remainder_stl <- elec_stl$time.series[, "remainder"]
pacf(remainder_stl)
acf(remainder_stl)
```

```{r}
remainder_str <- unlist(elec_str$output$random)
pacf(remainder_str)
acf(remainder_str)
```

The above plots show that 


### Short-term Forecasting

 TODO FORECAST 1 WEEK AHEAD USING STL AS WELL AS STR

```{r}
# # Load necessary libraries
# library(dplyr)
# library(ggplot2)
# 
# # Assuming elec_ts, elec_msts, elec_stl, and elec_str are already defined
# 
# # 1. Manual STL Forecasting
# stl_seasonal <- elec_stl$time.series[, "seasonal"]
# stl_trend <- mean(elec_stl$time.series[, "trend"])  # Using mean of trend
# 
# # Create forecast by repeating the last week of seasonal component
# last_week_seasonal <- tail(stl_seasonal, 7 * 48)
# stl_forecast <- rep(last_week_seasonal, 1) + stl_trend
# 
# # 2. Manual STR Forecasting
# str_daily <- elec_str$output$seasonal1
# str_weekly <- elec_str$output$seasonal2
# str_trend <- mean(elec_str$output$trend)  # Using mean of trend
# 
# # Create forecast by repeating the last week of each seasonal component
# last_week_daily <- tail(str_daily, 7 * 48)
# last_week_weekly <- tail(str_weekly, 7 * 48)
# str_forecast <- rep(last_week_daily, 1) + rep(last_week_weekly, 1) + str_trend
# 
# # 3. Prepare actual data for comparison
# actual_data <- window(elec_ts, start = time(elec_ts)[length(elec_ts) + 1], end = time(elec_ts)[length(elec_ts) + 7 * 48])
# 
# # 4. Calculate forecast accuracy measures
# calculate_accuracy <- function(forecast, actual) {
#   residuals <- actual - forecast
#   mae <- mean(abs(residuals))
#   rmse <- sqrt(mean(residuals^2))
#   mape <- mean(abs(residuals / actual)) * 100
#   
#   return(c(MAE = mae, RMSE = rmse, MAPE = mape))
# }
# 
# stl_accuracy <- calculate_accuracy(stl_forecast, actual_data)
# str_accuracy <- calculate_accuracy(str_forecast, actual_data)
# 
# # 5. Create a comparison dataframe
# forecast_comparison <- data.frame(
#   Time = time(actual_data),
#   Actual = as.numeric(actual_data),
#   STL_Forecast = stl_forecast,
#   STR_Forecast = str_forecast
# )
# 
# # 6. Plot comparison
# ggplot(forecast_comparison, aes(x = Time)) +
#   geom_line(aes(y = Actual, color = "Actual")) +
#   geom_line(aes(y = STL_Forecast, color = "STL Forecast")) +
#   geom_line(aes(y = STR_Forecast, color = "STR Forecast")) +
#   scale_color_manual(values = c("Actual" = "black", "STL Forecast" = "blue", "STR Forecast" = "red")) +
#   ggtitle("Comparison of Manual STL and STR Forecasts") +
#   xlab("Time") +
#   ylab("Electricity Demand") +
#   theme_minimal()
# 
# # 7. Print accuracy measures
# print("STL Forecast Accuracy:")
# print(stl_accuracy)
# 
# print("STR Forecast Accuracy:")
# print(str_accuracy)
```

# Conclusions

Overall, str() appears to perform the better fit.

## Practical Implications

`str()` appears to be better fit for the purpose, if the goal is to understand electricity demand. Out of the box it provides an easily readable plot of the seasonal components, and the confidence intervals are an added bonus. However, it is several orders of magnitude slower than `stl()` (see the appendix). If a quick and easy analysis is needed, it may be preferable to use `stl()`. 

## Possible Extensions

The above analysis could be extended by:

-   Performing an analysis over a holiday period such as Christmas, to
    see how it the seasonal components are affected by lower holiday
    demand.
-   Performing an analysis for long-term data, where yearly effects
    could be incorporated.
-   Incorporating a temperature component to the models.

# Bibliography

<https://otexts.com/fpp2/complexseasonality.html>

<https://cran.r-project.org/web/packages/stR/vignettes/stRvignette.html>

STL paper: <https://www.wessa.net/download/stl.pdf>

<https://www.mbie.govt.nz/building-and-energy/energy-and-natural-resources/energy-statistics-and-modelling/energy-statistics/electricity-statistics>

# Appendix

## `stl()` technical details

stl works by ...

## `str()` technical details

`str` works by ...

## Time Comparison

```{r}
library(microbenchmark)

# Ensure elec_ts and elec_msts are defined as before

benchmark_results <- microbenchmark(
  stl = stl(elec_ts, s.window="periodic"),
  str = AutoSTR(elec_msts, gapCV = 48, confidence = 0.95),
  times = 10
)

print(benchmark_results)

# Visualize the results
library(ggplot2)
autoplot(benchmark_results)
```

The above graph show that `stl()` is at least 3 orders of magnitude slower than `str()` on this dataset.
